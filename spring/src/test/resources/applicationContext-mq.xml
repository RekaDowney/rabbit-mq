<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:rabbit="http://www.springframework.org/schema/rabbit"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/rabbit
       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd
">

    <!-- Spring Bean 扫描，不扫描 Controller、 ControllerAdvice、 RestController 和 RestControllerAdvice 注解 -->
    <context:component-scan base-package="me.junbin.rabbitmq.spring" use-default-filters="true">
        <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
        <context:exclude-filter type="annotation" expression="org.springframework.web.bind.annotation.RestController"/>
        <context:exclude-filter type="annotation"
                                expression="org.springframework.web.bind.annotation.ControllerAdvice"/>
        <context:exclude-filter type="annotation"
                                expression="org.springframework.web.bind.annotation.RestControllerAdvice"/>
    </context:component-scan>

    <!-- 加载配置文件 -->
    <context:property-placeholder
            file-encoding="UTF-8"
            location="classpath:bundle/rabbitmq.properties"
    />

    <!-- 配置 RabbitMQ 连接池 -->
    <rabbit:connection-factory
            id="connectionFactory"
            host="${rabbitmq.host}"
            port="${rabbitmq.port}"
            username="${rabbitmq.username}"
            password="${rabbitmq.password}"
            virtual-host="${rabbitmq.vhost}"
    />

    <!-- 配置 RabbitAdmin，这样通过 rabbit 前缀配置的 交换机（exchange） 和 队列（queue） 在项目启动时会自动在 RabbitMQ 服务器上配置 -->
    <rabbit:admin
            id="rabbitAdmin"
            connection-factory="connectionFactory"
            auto-startup="true"
            ignore-declaration-exceptions="false"
    />

    <!-- 消息对象转换器 -->
    <bean
            id="rabbitGsonMessageConverter"
            class="me.junbin.rabbitmq.spring.converter.RabbitUtf8GsonMessageConverter"
    />

    <!-- 重试次数，最多重试 5 次 -->
    <bean
            id="retryPolicy"
            class="org.springframework.retry.policy.SimpleRetryPolicy"
            p:maxAttempts="5"
    />

    <!-- 重试时的退避算法，第一次失败休眠 0.5 秒后重试，第二次失败休眠 1 秒后重试，第三次失败休眠 2 秒后重试，依此类推。但最大休眠时间为 10 秒 -->
    <bean
            id="backOffPolicy"
            class="org.springframework.retry.backoff.ExponentialBackOffPolicy"
            p:initialInterval="500"
            p:maxInterval="10000"
            p:multiplier="2"
    />

    <!-- 重试机制，当所有重试都失败时抛出最后发生的异常 -->
    <bean
            id="retryTemplate"
            class="org.springframework.retry.support.RetryTemplate"
            p:retryPolicy-ref="retryPolicy"
            p:backOffPolicy-ref="backOffPolicy"
            p:throwLastExceptionOnExhausted="true"
    />

    <!-- 配置 RabbitTemplate，这个配置作为基础配置存在 -->
    <!-- message-converter 指定消息对象与 byte[] 的转换器 -->
    <!-- retry-template 指定所有 RabbitMQ 操作（发布、声明、确认、消费等）的失败重试机制 -->
    <rabbit:template
            id="rabbitTemplate"
            connection-factory="connectionFactory"
            encoding="UTF-8"
            message-converter="rabbitGsonMessageConverter"
    />

    <rabbit:queue
            id="fanoutQueue"
            name="${rabbitmq.fanout.queue}"
            durable="true"
            exclusive="false"
            auto-delete="false"
    />

    <rabbit:queue
            id="directQueue"
            name="${rabbitmq.direct.queue}"
    />

    <rabbit:queue
            id="topicQueue"
            name="${rabbitmq.topic.queue}"
    />

    <rabbit:queue
            id="headersQueue"
            name="${rabbitmq.headers.queue}"
    />

    <!-- 在 RabbitMQ 服务器上安装 delayed message exchange plugin 插件可以支持 delayed 配置 -->
    <rabbit:fanout-exchange id="fanoutExchange" name="${rabbitmq.fanout.exchange}">
        <rabbit:bindings>
            <rabbit:binding queue="fanoutQueue"/>
        </rabbit:bindings>
    </rabbit:fanout-exchange>

    <rabbit:direct-exchange id="directExchange" name="${rabbitmq.direct.exchange}">
        <rabbit:bindings>
            <rabbit:binding queue="directQueue" key="${rabbitmq.direct.routing.key}"/>
        </rabbit:bindings>
    </rabbit:direct-exchange>

    <rabbit:topic-exchange id="topicExchange" name="${rabbitmq.topic.exchange}">
        <rabbit:bindings>
            <rabbit:binding pattern="${rabbitmq.topic.routing.key}" queue="topicQueue"/>
        </rabbit:bindings>
    </rabbit:topic-exchange>

    <rabbit:headers-exchange id="headersExchange" name="${rabbitmq.headers.exchange}">
        <rabbit:bindings>
            <rabbit:binding queue="headersQueue">
                <rabbit:binding-arguments key-type="java.lang.String" value-type="java.lang.Object">
                    <description>Headers类型交换机头部配置</description>
                    <entry key="${rabbitmq.x.match}" value="${rabbitmq.x.match.any}"/>
                    <entry key="username" value="reka"/>
                    <!-- 没有指定 value-type，默认视为 java.lang.String，这时候如果发布消息时 Header 使用 java.lang.Integer 或者 java.lang.Long 则该消息不会被交换机递交到队列进行消费 -->
                    <entry key="age" value="24" value-type="java.lang.Long"/>
                </rabbit:binding-arguments>
            </rabbit:binding>
        </rabbit:bindings>
    </rabbit:headers-exchange>


    <!--
        &lt;!&ndash; 按照月份生成队列名称策略 &ndash;&gt;
        <bean
                id="namingStrategy"
                class="me.junbin.rabbitmq.spring.config.MonthQueueNameStrategy"
        />

        &lt;!&ndash; Spring RabbitMQ 在队列名称为空的时候，会调用 org.springframework.amqp.core.AnonymousQueue.UUIDNamingStrategy 命名策略生成队列名称 &ndash;&gt;
        &lt;!&ndash; 我们可以不使用 name 配置，直接使用 name-strategy 指定一个 org.springframework.amqp.core.AnonymousQueue.NamingStrategy beanName 来配置队列名称生成规则 &ndash;&gt;
        <rabbit:queue
                id="autoNamedQueue"
                naming-strategy="namingStrategy"
        />
    -->

    <!-- RabbitMQ 延迟队列参数配置 -->
    <rabbit:queue-arguments id="delayedQueueArguments" key-type="java.lang.String" value-type="java.lang.Object">
        <!-- 消息 TTL 配置，这里必须指定 value-type 为 java.lang.Long，否则将会报错 -->
        <!--
                <entry key="x-message-ttl" value="${rabbitmq.delayed}"/>
                上面这种配置没有指定 value-type 类型为 java.lang.Long 导致报错，这是因为会将 ${rabbitmq.delayed} 解析为 '3000' 字符串
                Caused by: com.rabbitmq.client.ShutdownSignalException: channel error;
                protocol method: #method<channel.close>(reply-code=406, reply-text=PRECONDITION_FAILED
                - invalid arg 'x-message-ttl' for queue 'delayed.queue' in vhost '/mq01':
                {unacceptable_type,longstr}, class-id=50, method-id=10)
        -->
        <!--
                上面这种配置没有指定 value-type 类型为 java.lang.Long 导致报错，这是因为会将 ${rabbitmq.delayed} 解析为 '3000' 字符串
                Caused by: com.rabbitmq.client.ShutdownSignalException: channel error;
                protocol method: #method<channel.close>(reply-code=406, reply-text=PRECONDITION_FAILED
                - inequivalent arg 'x-message-ttl' for queue 'delayed.queue' in vhost '/mq01':
                received '3000' but current is '3000', class-id=50, method-id=10)
        -->
        <entry key="x-message-ttl" value="${rabbitmq.delayed}" value-type="java.lang.Long"/>
        <!-- 队列 TTL 配置 -->
        <!--<entry key="x-expires" value="60000"/>-->
        <!-- 死信交换机 -->
        <entry key="x-dead-letter-exchange" value="${rabbitmq.delayed.handler.exchange}"/>
        <!-- 死信路由键 -->
        <entry key="x-dead-letter-routing-key" value="${rabbitmq.delayed.handler.routing.key}"/>
    </rabbit:queue-arguments>

    <rabbit:queue
            id="delayedQueue"
            name="${rabbitmq.delayed.queue}"
            queue-arguments="delayedQueueArguments"
    />

    <rabbit:direct-exchange
            id="delayedExchange"
            name="${rabbitmq.delayed.exchange}">
        <rabbit:bindings>
            <rabbit:binding queue="delayedQueue" key="${rabbitmq.delayed.routing.key}"/>
        </rabbit:bindings>
    </rabbit:direct-exchange>


    <rabbit:queue
            id="delayedHandlerQueue"
            name="${rabbitmq.delayed.handler.queue}"
    />

    <rabbit:direct-exchange
            id="delayedHandlerExchange"
            name="${rabbitmq.delayed.handler.exchange}"
            internal="true">
        <rabbit:bindings>
            <rabbit:binding queue="delayedHandlerQueue" key="${rabbitmq.delayed.handler.routing.key}"/>
        </rabbit:bindings>
    </rabbit:direct-exchange>


    <rabbit:queue
            id="autoDeleteQueue"
            name="auto.delete.queue"
            auto-delete="true"
            durable="false"
    />

    <rabbit:fanout-exchange
            id="autoDeleteFanoutExchange"
            name="auto.delete.fanout.exchange"
            auto-delete="true"
            durable="false">
        <rabbit:bindings>
            <rabbit:binding queue="autoDeleteQueue"/>
        </rabbit:bindings>
    </rabbit:fanout-exchange>

</beans>